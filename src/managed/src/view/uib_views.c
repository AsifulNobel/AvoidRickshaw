
/*******************************************************************************
* This file was generated by UI Builder.
* This file will be auto-generated each and everytime you save your project.
* Do not hand edit this file.
********************************************************************************/

#include "g_inc_uib.h"

#include "uib_views_inc.h"
#include "uib_util.h"
#include "uib_views.h"
#include "uib_app_manager.h"

#define ICON_MIN_SIZE 30
#define DEF_STARTUP_VIEW_NAME "view1"


uib_views_st gst_uib_views;
static window_obj* g_win_obj = NULL;

window_obj* create_window_obj();
window_obj* get_window_obj();
void destroy_window_obj();
char* get_current_config_name ();

void uib_views_orientation_handler(int orient_status, Evas_Object* evas_obj_win);
uib_view_context* startup_view_create(window_obj* win);
void set_targeted_view(const char* view_name);

static void (*uib_view1_config_delegate_portrait)();
static void (*uib_view1_config_delegate_landscape)();

char*g_view1_config_name_portrait = NULL;
char*g_view1_config_name_landscape = NULL;


char* g_views_config_delegate_name_portrait=NULL;
char* g_views_config_delegate_name_landscape=NULL;
char* g_views_current_config_name=NULL;
	
static uib_view_context* g_uib_saved_vc = NULL;
static void push_to_stack_uib_vc(uib_view_context* push_vc);
static void pop_from_stack_uib_vc(uib_view_context* pop_vc);
static void uib_views_current_view_redraw();

static void uib_views_orientation_changed_cb(void*, Evas_Object*, void*);

void uib_views_init() {
	if(!gst_uib_views.is_init) {
		gst_uib_views.is_init = true;
		gst_uib_views.create_window_obj = &create_window_obj;
		gst_uib_views.destroy_window_obj = &destroy_window_obj;
		gst_uib_views.get_window_obj = &get_window_obj;
		gst_uib_views.get_window = &get_window;
		gst_uib_views.get_conformant = &get_conformant;
		gst_uib_views.uib_views_current_view_redraw = &uib_views_current_view_redraw;
		gst_uib_views.uib_views_orientation_handler = &uib_views_orientation_handler;
		gst_uib_views.startup_view_create = &startup_view_create;
		gst_uib_views.set_targeted_view = &set_targeted_view;
		gst_uib_views.get_current_config_name = &get_current_config_name;

		// check resoltuion type
		const uib_device_info_st* uib_device_info = uib_app_manager_get_instance()->get_uib_device_info();
		switch(uib_device_info->resolution_type) {
		case e_resolution_HD:
			uib_view1_config_delegate_portrait = &uib_view1_config_HD_portrait;
			g_view1_config_name_portrait = "common";
			uib_view1_config_delegate_landscape = &uib_view1_config_HD_portrait;
			g_view1_config_name_landscape = "common";

			break;

		default:
			uib_view1_config_delegate_portrait = &uib_view1_config_HD_portrait;
			uib_view1_config_delegate_landscape = &uib_view1_config_HD_portrait;
			g_view1_config_name_portrait = "common";
			g_view1_config_name_landscape = "common";


			break;
		}
	}
}

uib_views_st* uib_views_get_instance() {
	uib_views_init();
	return &gst_uib_views;
}


void uib_views_create_callback(void* vc, Evas* e, Evas_Object* obj, void* event_info) {
	push_to_stack_uib_vc(vc);
	evas_object_smart_callback_call(obj, KEY_VIEW_CREATE, event_info);
}

void uib_views_destroy_callback(void* vc, Evas* e, Evas_Object* obj, void* event_info) {
	evas_object_smart_callback_call(obj, KEY_VIEW_DESTROY, event_info);
	pop_from_stack_uib_vc(vc);
}

// called by views_create_callback
void push_to_stack_uib_vc(uib_view_context* push_vc) {
	evas_object_data_set(push_vc->root_container, KEY_VIEW_VC_SAVE, g_uib_saved_vc);
	g_uib_saved_vc = push_vc;
}

// called by views_destroy_callback
void pop_from_stack_uib_vc(uib_view_context* pop_vc) {
	uib_view_context* rollback_vc = evas_object_data_get(pop_vc->root_container, KEY_VIEW_VC_SAVE);
	g_uib_saved_vc = rollback_vc;
	if(g_uib_saved_vc) {
		set_targeted_view(g_uib_saved_vc->view_name);
	}
}

void set_targeted_view(const char* view_name) {
	if(!strcmp(view_name,"view1")) {
		gst_uib_views.uib_view_target_config_portrait = uib_view1_config_delegate_portrait;
		gst_uib_views.uib_view_target_config_landscape = uib_view1_config_delegate_landscape;

		g_views_config_delegate_name_portrait = g_view1_config_name_portrait;
		g_views_config_delegate_name_landscape = g_view1_config_name_landscape;

		uib_util_rotation_set(g_win_obj->win, e_rotation_default);
	}
	int orientation=elm_win_rotation_get(uib_views_get_instance()->get_window());
	uib_views_get_instance()->uib_views_orientation_handler(orientation, uib_views_get_instance()->get_window());
}

void uib_views_orientation_handler(int orient_status, Evas_Object* evas_obj_win) {
	switch(DEF_UIB_ORIENT_TYPE(orient_status)) {
	case e_orientation_port:
		uib_views_get_instance()->uib_view_target_config_portrait();
		g_views_current_config_name = g_views_config_delegate_name_portrait;
		break;
	case e_orientation_land:
		uib_views_get_instance()->uib_view_target_config_landscape();
		g_views_current_config_name = g_views_config_delegate_name_landscape;
		break;
	default:
		uib_views_get_instance()->uib_view_target_config_portrait();
		g_views_current_config_name = g_views_config_delegate_name_portrait;
		break;
	}
}

char* get_current_config_name() {
	return g_views_current_config_name;
}


void uib_views_orientation_changed_cb(void *win, Evas_Object *obj, void *event_info) {
	int orientation=elm_win_rotation_get(win);
	uib_views_orientation_handler(orientation, win);
}

void uib_views_current_view_redraw() {
	uib_views_orientation_changed_cb(g_win_obj->win, NULL, NULL);
}


uib_view_context* startup_view_create(window_obj* win_obj)
{
	evas_object_smart_callback_add(win_obj->win, KEY_WM_ROTATION_CHANGED, uib_views_orientation_changed_cb, win_obj->win);
	uib_util_push_view(DEF_STARTUP_VIEW_NAME);
	return uib_app_manager_get_instance()->find_view_context(DEF_STARTUP_VIEW_NAME);
}

window_obj* create_window_obj()
{
	g_win_obj = calloc(1, sizeof(window_obj));
	if (!g_win_obj) {
		return NULL;
	}
	g_win_obj->win = elm_win_add(NULL, NULL, ELM_WIN_BASIC);
	elm_win_conformant_set(g_win_obj->win, EINA_TRUE);
	evas_object_show(g_win_obj->win);
	g_win_obj->bg = elm_bg_add(g_win_obj->win);
	evas_object_size_hint_weight_set(g_win_obj->bg, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
	elm_win_resize_object_add(g_win_obj->win, g_win_obj->bg);
	evas_object_show(g_win_obj->bg);

	elm_win_indicator_mode_set(g_win_obj->win, ELM_WIN_INDICATOR_SHOW);
	g_win_obj->conformant = elm_conformant_add(g_win_obj->win);
	evas_object_size_hint_weight_set(g_win_obj->conformant, EVAS_HINT_EXPAND, EVAS_HINT_EXPAND);
	elm_win_resize_object_add(g_win_obj->win, g_win_obj->conformant);
	evas_object_show(g_win_obj->conformant);

	g_win_obj->app_naviframe = elm_naviframe_add(g_win_obj->conformant);
	elm_object_content_set(g_win_obj->conformant, g_win_obj->app_naviframe);
	
	evas_object_data_set(g_win_obj->win, "root", g_win_obj);
	return g_win_obj;
}

void destroy_window_obj()
{
	if (g_win_obj) {
		evas_object_del(g_win_obj->win);
		free(g_win_obj);
		g_win_obj = NULL;
	}
}

window_obj* get_window_obj() {
	return g_win_obj;
}

Evas_Object* get_window() {
	return gst_uib_views.get_window_obj()->win;
}

Evas_Object* get_conformant() {
	return gst_uib_views.get_window_obj()->conformant;
}

/***********************************************************************************************
 *
 * item class callbacks
 *
 ***********************************************************************************************/
static Evas_Object* create_item_image(Evas_Object* parent, const char* path) {
	Evas_Object *icon = elm_icon_add(parent);
	char *resource_path = NULL;

	uib_util_rm_get_resource_path(APP_RESOURCE_TYPE_IMAGE, path, &resource_path);
			
	elm_image_file_set(icon, resource_path, NULL);
	if(resource_path) {
		free(resource_path);
	}
	evas_object_size_hint_min_set(icon, ELM_SCALE_SIZE(ICON_MIN_SIZE),ELM_SCALE_SIZE(ICON_MIN_SIZE));
	evas_object_show(icon);
	return icon;
}

char* uib_genlist_label_get(void *data, Evas_Object *obj, const char *part) {
	uib_genlist_item *item = (uib_genlist_item*)data;
	if(!strcmp(part, "elm.text")) {
		if (item->label) {
			return strdup(item->label);
		}
	}
	else if (!strcmp(part, "elm.text.sub")) {
		if (item->sub_label) {
			return strdup(item->sub_label);
		}
	}
	return NULL;
}

Evas_Object* uib_genlist_icon_get(void *data , Evas_Object *obj, const char *part) {
	uib_genlist_item *item = (uib_genlist_item*) data;
	if (!strcmp(part, "elm.swallow.icon")) {
		if(item->icon_standard){
			Evas_Object *ic = elm_icon_add(obj);
			elm_icon_standard_set(ic, item->icon_standard);
			evas_object_size_hint_min_set(ic, ELM_SCALE_SIZE(ICON_MIN_SIZE),ELM_SCALE_SIZE(ICON_MIN_SIZE));
			return ic;
		} else if(item->icon_path){
			return create_item_image(obj, item->icon_path);
		}
	}
		
		
	if (!strcmp(part, "elm.swallow.end")) {
		if (item->end_icon_standard) {
			Evas_Object *ic = elm_icon_add(obj);
			elm_icon_standard_set(ic, item->end_icon_standard);
			evas_object_size_hint_min_set(ic, ELM_SCALE_SIZE(ICON_MIN_SIZE),ELM_SCALE_SIZE(ICON_MIN_SIZE));
			return ic;
		} else if (item->end_icon_path) {
			return create_item_image(obj, item->end_icon_path);
		}
	}
	return NULL;
}

Eina_Bool uib_genlist_state_get(void *data , Evas_Object *obj , const char *part) {
	return EINA_FALSE;
}

void uib_genlist_del(void *data , Evas_Object *obj) {
	uib_genlist_item *item = (uib_genlist_item*)data;
	if (item) {
		if (item->label) free(item->label);
		if (item->sub_label) free(item->sub_label);
		if (item->icon_path) free(item->icon_path);
		if (item->icon_standard) free(item->icon_standard);
		if (item->end_icon_path) free(item->end_icon_path);
		if (item->end_icon_standard) free(item->end_icon_standard);
		free(item);
	}
}

char* uib_gengrid_label_get(void *data, Evas_Object *obj, const char *part) {
	uib_gengrid_item *item = (uib_gengrid_item*)data;
	if (item->label) {
		return strdup(item->label);
	} else {
		return NULL;
	}
}

Evas_Object* uib_gengrid_icon_get(void *data, Evas_Object *obj, const char *part) {
	uib_gengrid_item *item = (uib_gengrid_item*) data;
	if (!strcmp(part, "elm.swallow.icon") && item->icon_path) {
		return create_item_image(obj, item->icon_path);
	} else {
		return NULL;
	}
}

Eina_Bool uib_gengrid_state_get(void *data, Evas_Object *obj, const char *part) {
	return EINA_FALSE;
}

void uib_gengrid_del(void *data, Evas_Object *obj) {
	uib_gengrid_item *item = (uib_gengrid_item*)data;
	if (item) {
		if (item->label) free(item->label);
		if (item->icon_path) free(item->icon_path);
		free(item);
	}
}


Elm_Genlist_Item_Class* _itc = NULL;
Elm_Genlist_Item_Class* _itg = NULL;
		
Elm_Gengrid_Item_Class* _gic = NULL;
Elm_Gengrid_Item_Class* _gig = NULL;
Elm_Gengrid_Item_Class* _gia = NULL;
Elm_Gengrid_Item_Class* _gib = NULL;

void initialize_genlist_class(const char* style) {
	if (!_itc) {
		_itc = elm_genlist_item_class_new();
		_itc->item_style = style;
		_itc->func.text_get = uib_genlist_label_get;
		_itc->func.content_get = uib_genlist_icon_get;
		_itc->func.state_get = uib_genlist_state_get;
		_itc->func.del = uib_genlist_del;
	}
	if (!_itg) {
		_itg = elm_genlist_item_class_new();
		_itg->item_style = "group_index";
		_itg->func.text_get = uib_genlist_label_get;
		_itg->func.content_get = uib_genlist_icon_get;
		_itg->func.state_get = uib_genlist_state_get;
		_itg->func.del = uib_genlist_del;
	}
}

void initialize_gengrid_class(const char* style) {
	if (!_gic) {
		_gic = elm_gengrid_item_class_new();
		_gic->item_style = style;
		_gic->func.text_get = uib_gengrid_label_get;
		_gic->func.content_get = uib_gengrid_icon_get;
		_gic->func.state_get = uib_gengrid_state_get;
		_gic->func.del = uib_gengrid_del;
	}

	if (!_gig) {
		_gig = elm_gengrid_item_class_new();
		_gig->item_style = "group_index";
		_gig->func.text_get = uib_gengrid_label_get;
		_gig->func.content_get = uib_gengrid_icon_get;
		_gig->func.state_get = uib_gengrid_state_get;
		_gig->func.del = uib_gengrid_del;
	}

	if (!_gia) {
		_gia = elm_gengrid_item_class_new();
		_gia->item_style = "album-preview";
		_gia->func.text_get = uib_gengrid_label_get;
		_gia->func.content_get = uib_gengrid_icon_get;
		_gia->func.state_get = uib_gengrid_state_get;
		_gia->func.del = uib_gengrid_del;
	}

	if (!_gib) {
		_gib = elm_gengrid_item_class_new();
		_gib->item_style = "block";
		_gib->func.text_get = uib_gengrid_label_get;
		_gib->func.content_get = uib_gengrid_icon_get;
		_gib->func.state_get = uib_gengrid_state_get;
		_gib->func.del = uib_gengrid_del;
	}
}

Elm_Object_Item* create_multibuttonentry_item(Evas_Object* multibuttonentry, const char* label, Evas_Smart_Cb func, void* data) {
	Elm_Object_Item* item = elm_multibuttonentry_item_append(multibuttonentry, label, func, data); 
	return item;
}

Elm_Object_Item* create_gengrid_item(Evas_Object* gengrid, const char* style, const char* label, const char* path, Evas_Smart_Cb func, void* data) {
	uib_gengrid_item* item = malloc(sizeof(uib_gengrid_item));
	memset(item, 0x0, sizeof(uib_gengrid_item));	
	item->label = strdup(label);
	item->icon_path = strdup(path);

	if(!strcmp(style, "album-preview")) {
		return elm_gengrid_item_append(gengrid, _gia, item, func, data);
	} else if(!strcmp(style, "block")) {
		return elm_gengrid_item_append(gengrid, _gib, item, func, data);
	} else if(!strcmp(style, "group_index")) {
		return elm_gengrid_item_append(gengrid, _gig, item, func, data);
	}
	return elm_gengrid_item_append(gengrid, _gic, item, func, data);
}

Elm_Object_Item* create_genlist_item(Evas_Object* genlist, const char* label, const char* sub_label, const char* icon_path, const char* icon_standard, const char* end_icon_path, const char* end_icon_standard, Elm_Object_Item* parent, Elm_Genlist_Item_Type type, Evas_Smart_Cb func, void* data){
	uib_genlist_item* item = malloc(sizeof(uib_genlist_item));
	memset(item, 0x0, sizeof(uib_genlist_item));

	item->label = strdup(label);
	item->sub_label = strdup(sub_label);
	if(strlen(icon_standard) != 0){
		item->icon_standard = strdup(icon_standard);
	} else if(strlen(icon_path) != 0){
		item->icon_path = strdup(icon_path);
    }
	
	if(strlen(end_icon_standard) != 0){
		item->end_icon_standard = strdup(end_icon_standard);
	} else if(strlen(end_icon_path) != 0){
		item->end_icon_path = strdup(end_icon_path);
	}
	
	if(ELM_GENLIST_ITEM_GROUP == type){
		return elm_genlist_item_append(genlist, _itg, item, parent, type, func, data);
	}
	return elm_genlist_item_append(genlist, _itc, item, parent, type, func, data);
}			
